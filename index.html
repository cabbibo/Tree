<html>

  <head>
    <link rel="stylesheet" type="text/css" href="main.css">
    
    <style>

    html{

      background:#000;

    }
   // #container{ position:absolute; left:0px; top:0px; z-index:0; width:100%; height:100%; display:block; overflow:hidden}

    @font-face {
      font-family: "GeoSans";
      src: url( "GeosansLight.ttf" );
    }

    #GUI{

      position:fixed;
      right:0px;
      top:0px;
      z-index:999;

    }

    #stats{

      position:absolute;
      top:3px;
      right:0px;
      height:14px;
      overflow:hidden;


    }
    #Info{
      display:none;
    }
   /* #Info{
      z-index: 999;
      color: #fff;
      background: #222;
      border: 1px solid white;
      position: fixed;
      padding: 10px;
    }

     #stats{
      z-index: 999;
      bottom:0px;
      left:0px;
      //border: 1px solid white;
      position: fixed;
      margin:10px;
    }*/
    </style>
  </head>

  <body>

  <div id="Info">
    Total Verts: <div id="totalVerts"></div>
  </div>

  <div id="GUI"></div>
  <script src="three.js"></script>
  <script src="jquery.min.js"></script>
  <script src="stats.min.js"></script>
  <script src="dat.gui.min.js"></script>
  <script src="underscore.js"></script>
  <script src="addSocialMedia.js"></script>
  
  <script src="Looper.js"></script>
  <script src="AudioController.js"></script>
  <script src="LoadedAudio.js"></script>
  <script src="AudioTexture.js"></script>
  
  <script src="ShaderLoader.js"></script>
  <script src="OrbitControls.js"></script>
  <script src="TextCreator.js"></script>
  <script src="Loader.js"></script>

  <script src="ObjectControls.js"></script>
  <script src="Tree.js"></script>

  <script>


    addSocialMedia( SOCIAL_MEDIA );

    var G = {};

    G.tmpV3 = new THREE.Vector3();

    var camera, scene , renderer, controls , stats , clock;

    var tree , treeMat , floor , lights =[];

    var timer = { type:"f" , value:0 };
    var dT = { type:"f" , value: 0 };
    var loader = new Loader();

    loader.onStart = function(){
      init();
      animate();
    }

    loader.onCurtainLifted = function(){

      looper.start();

    }

    var audioController = new AudioController();
    

    var neededToLoad = 0;
    var loaded = 0;


    var AUDIO = {};

    var lightArray = [

    {

      title:"Luppulagio - Sigur Ros",
      audio:"lup", 
      color: new THREE.Vector3( 1.  , .5 , .3 ),
      position: new THREE.Vector3(),
      early: true
    },

    { 
      title:"Snaredrum Therapy - Cid Rim",
      audio:"snare",       
      color: new THREE.Vector3( 1.  , .2 , .3 ),
      position: new THREE.Vector3(),
      early: true

    },

    { 
      title:"Glosoli - Sigur Ros",
      audio:"glo", 
      color: new THREE.Vector3( .4 , .1 , 1. ),
      position: new THREE.Vector3(),
      early: true

    },


    { 
      title:"Game - Susanna and the Magical Orchestra",
      audio:"game", 
      color: new THREE.Vector3( .6 , .4 , 1. ),
      position: new THREE.Vector3(),
      early: true

    },

    { 
      title:"All Alright - Sigur Ros",
      audio:"allRight",  
      color: new THREE.Vector3( .4 , .9 , .8),
      position: new THREE.Vector3(),
      early: false
    },

    { 
      title:"Starting Over - Typhoon",
      audio:"startingOver",       
      color: new THREE.Vector3( 1. , .7 , 0 ),
      position: new THREE.Vector3(),
      early: false
    },

    { 
      title:"Hallelujah - Susanna and the Magical Orchestra",
      audio:"tongue",       
      color: new THREE.Vector3( .1 , .4 , 1 ),
      position: new THREE.Vector3(),
      early: false
    },
    
    ]

    for( var i = 0; i < lightArray.length; i++ ){

      loader.beginLoading();
      var name = lightArray[i].audio;

      file = 'audio/' + name + '.mp3';
      AUDIO[ name ] = new LoadedAudio( audioController , file );

      AUDIO[ name ].onLoad = function(){

        loader.endLoading();

      }.bind( AUDIO[ name ] );

    }



    
    var looper = new Looper( audioController , timer , {

      beatsPerMinute: 120,
      beatsPerMeasure: 4,
      measuresPerLoop: 8

    });


    var TEXTURES = {};

    var normals = [];
    var iris    = [];


    var totalVerts = document.getElementById('totalVerts');
    var totalFaces = document.getElementById('totalFaces');


    
    var params = {
      radius:                 100,
      height:                1000,
      sides:                    8,
      numOf:                   18, 
      randomness:             180,
      slices:                 100,
      startingChance:          4.,
      chanceReducer:           .9,
      randomnessReducer:       .5,
      sliceReducer:            .7,
      numOfReducer:            .8,
      progressionPower:        1.4,
      lengthReduction:         .5,
      maxIterations:            3,
      material:           treeMat,
      createTree: function(){
        createTree();
      }
    }

    
    
    var gui = new dat.GUI({autoPlace:false});

    gui.close();

    var guiContainer = document.getElementById('GUI');
    guiContainer.appendChild(gui.domElement);


    var treeGui = gui.addFolder( 'Tree Params' );

    var g = treeGui.add( params , 'radius' , 0 , 400 )
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'height' , 0 , 4000 )
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'sides' , 0 , 20 ).step(1)
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'numOf' , 4 , 40).step(1)
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'randomness' , 0 , 500 )
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'slices' , 10 , 500 ).step(1)
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'startingChance' , 0 , 10 )
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'chanceReducer' , 0 , .99)
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'randomnessReducer' , 0 , .99 )
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'sliceReducer' , 0 , .99 )
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'numOfReducer' , 0 , .99)
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'progressionPower' , 0 , 5 )
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'lengthReduction' , 0 , 1 )
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'maxIterations' , 0 , 5).step(1)
    g.onFinishChange(function(){createTree()});

    var g = treeGui.add( params , 'createTree' ).name('Recreate Tree');
    g.onFinishChange(function(){createTree()});


    var lightParams = {

      cutoff: { type:"f" , value:1000 } ,
      power: { type:"f" , value:1 } ,
      positions: { type:"v3v" , value:[] },
      textures:{   type:"tv" , value:[] },
      colors: { type:"v3v" , value:[] },      
      normalScale:{ type:"f" , value:.5 } ,
      texScale: { type:"f" , value:1.5 } ,

    }

    var lightGui = gui.addFolder( 'Light Params' );

    var g = lightGui.add( lightParams.cutoff , 'value' ).name( 'cutoff' );
    var g = lightGui.add( lightParams.power  , 'value' ).name( 'power' );
    var g = lightGui.add( lightParams.normalScale , 'value' ).name( 'normalScale' );
    var g = lightGui.add( lightParams.texScale  , 'value' ).name( 'texScale' );
    
    var floorParams = {

      normalScale:{ type:"f" , value:.3 } ,
      texScale: { type:"f" , value:7 } ,
      bumpHeight: { type:"f" , value:200 } ,
      bumpSize: { type:"f" , value:.001 } ,
      bumpSpeed: { type:"f" , value:.1 } ,
      bumpCutoff: { type:"f" , value:.5 } ,
      normalMap : { type:"f" , value:0 },
      iriMap    : { type:"f" , value:0 },

    }

    var fP = floorParams
    var floorGui = gui.addFolder( 'Floor Params' );

    var g = floorGui.add( fP.normalScale  , 'value' ).name( 'normalScale' );
    var g = floorGui.add( fP.texScale     , 'value' ).name( 'texSize' );
    var g = floorGui.add( fP.bumpHeight   , 'value' ).name( 'bumpHeight' );
    var g = floorGui.add( fP.bumpSize     , 'value' ).name( 'bumpSize' );
    var g = floorGui.add( fP.bumpSpeed    , 'value' ).name( 'bumpSpeed' );
    var g = floorGui.add( fP.bumpCutoff    , 'value' ).name( 'bumpCutoff' );


    var treeRenderParams = {

      normalScale:{ type:"f" , value:.3 } ,
      texScale: { type:"f" , value:.01 } ,

    }

    var tP = treeRenderParams 
    var treeRenderGui = gui.addFolder( 'Tree Render Params' );

    var g = treeRenderGui.add( tP.normalScale  , 'value' ).name( 'normalScale' );
    var g = treeRenderGui.add( tP.texScale     , 'value' ).name( 'texSize' );
    var shaders = new ShaderLoader( 'shaders' );


    loader.beginLoading();

    shaders.load( 'vs-floor' , 'floor' , 'vertex'    );
    shaders.load( 'fs-floor' , 'floor' , 'fragment'    );
    shaders.load( 'vs-tree' , 'tree' , 'vertex'    );
    shaders.load( 'fs-tree' , 'tree' , 'fragment'    );
    shaders.load( 'vs-treeLight' , 'treeLight' , 'vertex'    );
    shaders.load( 'fs-treeLight' , 'treeLight' , 'fragment'    );

    shaders.shaderSetLoaded = function(){ loader.endLoading(); }




    loadTexture( 'moss' , 'img/normals/sand.png' , normals );

    
    /*loadTexture( 'iriGreen' , 'img/iri/green.png' , iris );
    //loadTexture( 'iriRed' , 'img/iri/red.png' , iris );
    loadTexture( 'iriGold' , 'img/iri/gold.png' , iris );
    loadTexture( 'iriBlue' , 'img/iri/turq.png' , iris );
    loadTexture( 'iriBlue' , 'img/iri/pinkRed.png' , iris );*/
   // loadTexture( 'iriBlue' , 'img/iri/blue.png' , iris );
    //loadTexture( 'iriPurp' , 'img/iri/greenBluePurp.png' , iris );


    function init(){

      clock = new THREE.Clock();
      scene = new THREE.Scene();
      
      camera = new THREE.PerspectiveCamera( 
        50 ,
        window.innerWidth / window.innerHeight,
        2000 / 100 ,
        2000 * 100
      );

      // placing our camera position so it can see everything
      camera.position.z = 2000 ;

      camera.velocity = new THREE.Vector3();

      objectControls = new ObjectControls( camera );

            console.log('STARSd');

      textCreator = new TextCreator( 300);

      // Getting the container in the right location
      container     = document.createElement( 'div' );
      container.id  = 'container';
      
      document.body.appendChild( container );

      // Getting the stats in the right position
      stats = new Stats();
      stats.domElement.id = 'stats';
      guiContainer.appendChild( stats.domElement );


      // Setting up our Renderer
      renderer = new THREE.WebGLRenderer();

      renderer.setSize( window.innerWidth, window.innerHeight );
      container.appendChild( renderer.domElement );


      // Making sure our renderer is always the right size
      window.addEventListener( 'resize', onWindowResize , false );
      
      
      //controls = new THREE.TrackballControls( camera,renderer.domElement );

      controls = new THREE.OrbitControls( camera , renderer.domElement );
	  controls.damping = 0.1;
      //controls.addEventListener( 'change', render );

      var lightGeo =  new THREE.IcosahedronGeometry( 50 , 2 );
      var lightMat = new THREE.MeshNormalMaterial();
      
      for( var i = 0; i < lightArray.length; i++ ){

        var height = (i+3 / 8 ) * 100.; 

        var t = Math.random() * 2 * Math.PI;

        var r = 1000;

        var x = r * Math.cos( t );
        var z = r * Math.cos( t );

        var mat = new THREE.ShaderMaterial({

          uniforms:{
            
            timer:timer,
            t_normal:{ type:"t" , value: TEXTURES.moss },
            normalScale:  lightParams.normalScale,
            texScale:     lightParams.texScale,
            cameraPos:{ type:"v3" , value: camera.position },
            color:{ type:"v3" , value:lightArray[i].color},
            t_audio:{ type:"t" , value: AUDIO[ lightArray[i].audio ].texture },
            hovered:{ type:"f" , value: 0 }
          },

          vertexShader:shaders.vs.treeLight,
          fragmentShader:shaders.fs.treeLight

        });
        light = new THREE.Mesh( lightGeo, mat );

        light.position.x =  x;
        light.position.z =  z;
        light.position.y = height;

        light.radius = r;
        light.height = height;
        light.theta  = t;

        light.playing  = true;

        light.audio = AUDIO[ lightArray[i].audio ];
        light.texture = light.audio.texture;

        light.titleMesh = textCreator.createMesh( lightArray[i].title ,{
     
          size: 20,
          //margin: 20000,
        });

        light.titleMesh.material.transparent = true;
        light.titleMesh.material.blending = THREE.AdditiveBlending;
        light.titleMesh.material.depthWrite = false;
        light.titleMesh.material.opacity = 0;

        light.titleMesh.materialNeedsUpdate = true;
        //light.titleMesh.position.y = 200;

        scene.add( light.titleMesh );

        console.log( 'LIGHT AUDIO' );
        console.log( light.audio );
        light.color = lightArray[i].color;


        looper.everyLoop( function(){ this.audio.play() }.bind( light ) );

        light.audio.updateAnalyser = true;
        light.audio.updateTexture = true;

        lightParams.textures.value.push( light.texture );
        lightParams.positions.value.push( light.position );
        lightParams.colors.value.push( light.color );

        light.hoverOver = function(){

          console.log('HELLO' );
          this.hovered = true;
          this.titleMesh.position.copy( this.position );
          this.titleMesh.position.y += 100;

          this.titleMesh.lookAt( camera.position );

          this.titleMesh.material.opacity = 1;
          this.material.uniforms.hovered.value = 1;
          for( var i = 0; i < lights.length; i++ ){

            if( lights[i]  != this ){

              lights[i].audio.filter.frequency.value = 300;

            }

          }


        }.bind( light );

       
        light.hoverOut = function(){

          console.log('HELLO' );
          this.hovered = false;
        
          this.titleMesh.material.opacity = 0;
          this.material.uniforms.hovered.value = 0;


            for( var i = 0; i < lights.length; i++ ){

            if( lights[i]  != this ){

              var f =  lights[i].audio.filter;
              f.frequency.value = f.frequency.maxValue;

            }

          }


          console.log( this );
          console.log( this.hovered );
        }.bind( light );

        light.select = function(){

          this.playing = !this.playing;

          if( this.playing === false ){

            this.audio.gain.gain.value = 0;

          }else{

          this.audio.gain.gain.value = .8;


          }

        }.bind( light );


        objectControls.add( light );
        scene.add( light );

        lights.push( light );

      }

      var floorGeo =  new THREE.PlaneGeometry( 5000 , 5000 , 100 , 100 );

      var floorMat = new THREE.ShaderMaterial({


        uniforms:{
          timer:timer,
          t_normal:{ type:"t" , value: TEXTURES.moss },
          t_iri:{ type:"t" , value: TEXTURES.iriTurq },
          normalScale:  floorParams.normalScale,
          texScale:     floorParams.texScale,
          bumpHeight:   floorParams.bumpHeight,
          bumpSize:     floorParams.bumpSize,
          bumpSpeed:    floorParams.bumpSpeed,
          bumpCutoff:    floorParams.bumpCutoff,
          lightCutoff:   lightParams.cutoff,
          lightPower:    lightParams.power,
          lightPositions: lightParams.positions, 
          lightTextures: lightParams.textures,
          lightColors: lightParams.colors,
          cameraPos:{ type:"v3" , value: camera.position }
        },
        vertexShader: shaders.vs.floor,
        fragmentShader: shaders.fs.floor,

      });


      floor = new THREE.Mesh( floorGeo , floorMat );

      floor.rotation.x = -Math.PI / 2;

      floor.position.y = -450
      scene.add( floor );


      
      treeMat = new THREE.ShaderMaterial({


        uniforms:{
          timer:timer,
          t_normal:{ type:"t" , value: TEXTURES.moss },
          t_iri:{ type:"t" , value: TEXTURES.iriTurq },
          normalScale:  treeRenderParams.normalScale,
          texScale:     treeRenderParams.texScale,
          lightCutoff:   lightParams.cutoff,
          lightPower:    lightParams.power,
          lightPositions: lightParams.positions,
          lightTextures: lightParams.textures,
          lightColors: lightParams.colors,
          cameraPos:{ type:"v3" , value: camera.position }
        },
        vertexShader: shaders.vs.tree,
        fragmentShader: shaders.fs.tree,

      });


      params.material = treeMat;


      // to keep any 'roots' from showing
      var base = new THREE.Mesh(
        new THREE.PlaneGeometry( 100000 , 100000 ),
        new THREE.MeshBasicMaterial({color: 0x000000 })
      );

      base.rotation.x = - Math.PI / 2;
      base.position.y = -453;
      scene.add( base );
      createTree();


    }

    function render(){

      renderer.render( scene , camera );

    }

    function animate(){

      dT.value = clock.getDelta();
      timer.value += dT.value;

      objectControls.update();

      audioController.update();

      for( var i =0 ; i < lights.length; i++ ){

        var l = lights[i];

        if( !l.hovered && l.playing ){
          
          l.theta += .001 + i * .001;
          l.position.x = l.radius * Math.cos( l.theta );
          l.position.z = l.radius * Math.sin( l.theta );
          l.position.y = l.height + Math.cos( (l.theta*  (i+5)/3 )) * 100;

          l.rotation.x += (i + 5) / 1000;
          l.rotation.y -= ((i%1)*10 + 5) / 1000;
          l.rotation.z -= (20 - i) / 2000;
          G.tmpV3.copy( l.position );
          G.tmpV3.sub( camera.position );

          var length = G.tmpV3.length();

          var a = Math.min( 1000. / length , 1. );

          l.audio.gain.gain.value = a;

        }


        

      }

      stats.update();
      controls.update();
      render();
      //renderer.render( scene , camera );

      requestAnimationFrame( animate );

    }

    function createTree( ){

      console.log( '---------------------------------------------' );
      console.log( '            NEW TREE                         ' );
      console.log( '---------------------------------------------' );
     
      if( tree ){
        scene.remove( tree );
      }

      tree = new Tree( params );

      tree.position.y = -500;


      if( tree.maxHit === true ){

        totalVerts.style.color = '#ff0000';

      }else{
  
        totalVerts.style.color = '#ffffff';

      }

      scene.add( tree );

      totalVerts.innerHTML = tree.geometry.totalVerts;
    }

    // Resets the renderer to be the proper size
    function onWindowResize(){

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function loadTexture( name , file , array ){

      loader.beginLoading();

      // callback
      var cb = function(){
        loader.endLoading(); 
      };

      // mapping
      var m = THREE.UVMapping;

      // load call
      var l = THREE.ImageUtils.loadTexture;

      TEXTURES[ name ] = l( file , m , cb );
      TEXTURES[ name ].wrapS = THREE.RepeatWrapping;
      TEXTURES[ name ].wrapT = THREE.RepeatWrapping;

      array.push( TEXTURES[name] );

    }


   function onLoad(){


     loaded ++;
     console.log( loaded );

    if( loaded === neededToLoad ){

      //init();
      //animate();
      //stream.play();

    }

  }

  </script>
</body>
</html>

